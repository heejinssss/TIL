# 0208-09 : String

## 컴퓨터에서의 문자 표현

- 글자 A를 메모리에 저장하는 방법에 대해서 생각해보자
- 물론 칼로 A라는 글자를 새기는 방식은 아닐 것이다. 메모리는 숫자만을 저장할 수 있기 때문에 A라는 글자의 모양 그대로 비트맵으로 저장하는 방법을 사용하지 않는 한(이 방법은 메모리 낭비가 심하다) 각 문제에 대해서 대응되는 숫자를 정해 놓고 이것을 메모리에 저장하는 방법이 사용될 것이다.
- 영어가 대소문자 합쳐서 52 → 6(64가지)비트면 모두 표현할 수 있다. 이를 코드체계라고 한다.
    - 000000 → ‘a’, 000001 → ‘b’
- 그런데? 네트워크가 발전되기 전 미국의 각 지역별로 코드체계를 정해놓고 사용했지만 네트워크(인터넷 : 인터넷은 미국에서 발전했다)이 발전하면서 서로 간에 정보를 주고 받을 때 정보를 달리 해석한다는 문제가 생겼다.
- 그래서! 혼동을 피하기 위해 표준안을 만들기로 했다. 바로 이러한 목적으로 1967년, 미국에서 ASCII(American Standard Code for Imformation Interchange)라는 문자 인코딩 표준이 제정되었다.
- ASCII는 7bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 묹자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져 있다.

### 출력 가능한 아스키 문자 (32~126)

| ASCII |  | ASCII |  | ASCII |  | ASCII |  | ASCII |  | ASCII |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 32 |  | 48 | 0 | 64 | @ | 80 | P | 96 | ` | 112 | p |
| 33 | ! | 49 | 1 | 65 | A | 81 | Q | 97 | a | 113 | q |
| 34 | “ | 50 | 2 | 66 | B | 82 | R | 98 | b | 114 | r |
| 35 | # | 51 | 3 | 67 | C | 83 | W | 99 | c | 115 | s |
| 36 | $ | 52 | 4 | 68 | D | 84 | T | 100 | d | 116 | t |
| 37 | % | 53 | 5 | 69 | E | 85 | U | U101 | e | 117 | u |
| 38 | & | 54 | 6 | 70 | F | 86 | V | 102 | f | 118 | v |
| 39 | ‘ | 55 | 7 | 71 | G | 87 | W | 103 | g | 119 | w |
| 40 | ( | 56 | 8 | 72 | H | 88 | X | 104 | h | 120 | x |
| 41 | ) | 57 | 9 | 73 | I | 89 | Y | 105 | i | 121 | y |
| 42 | * | 58 | : | 74 | J | 90 | Z | 106 | j | 122 | z |
| 43 | + | 59 | ; | 75 | K | 91 | [ | 107 | k | 123 | { |
| 44 | , | 60 | < | 76 | L | 92 | \ | 108 | l | 124 | | |
| 45 | - | 61 | = | 77 | M | 93 | ] | 109 | m | 125 | } |
| 46 | . | 62 | > | 78 | N | 94 | ^ | 110 | n | 126 | ~ |
| 47 | / | 63 | ? | 79 | O | 95 | _ | 111 | o |  |  |

### 확장 아스키

- 확장 아스키는 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호이다. 표준 아스키는 7bit를 사용하여 문자를 표현하는 데 비해 확장 아스키는 1B 내의 8bit를 모두 사용함으로써 추가적인 문자를 표현할 수 있다. 컴퓨터 생산자와 소프트웨어 개발자가 여러가지 다양한 문자에 할당할 수 있도록 하고 있다. 이렇게 할당된 확장 부호는 표준 아스키와 같이 서로 다른 프로그램이나 컴퓨터 사이에 교환되지 못한다. 그러므로 표준 아스키는 마이크로컴퓨터 하드웨어 밑 소프트웨어 사이에서 세계적으로 통용되는 데 비해, 확장 아스키는 프로그램이나 컴퓨터 또는 프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바르게 해독될 수 있다. 오늘날 대부분의 컴퓨터는 문자를 읽고 쓰는데 ASCII형식을 사용한다.

### 유니코드

- 그런데! 컴퓨터가 발전하면서 미국뿐 아니라 각 나라에서도 컴퓨터가 발전했으며 각 국가들은 자국의 문자를 표현하기 위하여 코드 체계를 만들어서 사용하게 되었다. (우리나라도 아주 오래된 이야기지만 한글 코드 체계를 만들어 사용했고, 조합형, 완성형 두 종류를 가지고 있었다.)
- 인터넷이 전 세계로 발전하면서 ASCII를 만들었을 때의 문제와 같은 문제가 국가간에 정보를 주고 받을 때 발생했다. 자국의 코드 체계를 타 국가가 가지고 있지 않으면 정보를 잘못 해석할 수밖에 없었다. 그래서 다국어 처리를 위해 표준을 마련했다. 이를 유니코드라고 한다.
- UCS-2(Universal Character Set 2)
- UCS-4(Universal Character Set 4)
- 유니코드를 저장하는 변수의 크기를 정의
- 그러나, 바이트 순서에 대해서 표준화하지 못했다. 다시 말해, 파일을 인식할 때 이 파일이 UCS-2, UCS-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제가 발생한다. 그래서! 유니코드의 적당한 외부 인코딩이 필요하게 되었다.
- 유니코드 인코딩 (UTF : Unicode Transformation Format)
    - UTF-8 (in web)
        - MIN : 8bit, MAX : 32bit (1 Byte * 4)
    - UTF-16 (in windows, java)
        - MIN : 1bit, MAX : 32bit (2Byte * 2)
    - UTF-32 (in Unix)
        - MIN : 32bit, MAX : 32bit (4 Byte * 1)

### Python 인코딩

- 2.x 버전 - ASCII → `#-*- coding: utf08 -*-` (첫 줄에 명시)
- 3.x 버전 - 유니코드 UTF-8 → 생략 가능
- 다른 인코딩 방식으로 처리 시 첫 줄에 작성하는 위 항목에 원하는 인코딩 방식을 지정해주면 됨

## 문자열

### Java에서 String 클래스에 대한 메모리 배치 예

- `java.lang.String` 클래스에는 기본적인 객체 메타 데이터 외에도 네 가지 필드들이 포함되어 있는데, hash 값(hash), 문자열 길이(count), 문자열 데이터의 시작점(offset), 그리고 실제 문자열 배열에 대한 참조(value)이다.

### C언어에서 문자열 처리

- 문자열은 문자들의 배열 형태로 구현된 응용 자료형
- 문자 배열에 문자열 저장할 때는 항상 마지막에 끝을 표시하는 Null 문자(’\0’)을 넣어줘야 한다.

```c
char ary[] = {'a', 'b', 'c', '\0'}; // 또는 char ary[]="abc";
```

- 문자열 처리에 필요한 연산을 함수 형태로 제공한다.
- `strlen()`, `strcpy()`, `strcmp()`, ...

### [참고] strlen() 함수 만들기

```python
def strlen(a):
    i = 0
    while a[i] != '\0':
        i += 1
    return i

a = ['a', 'b' 'c', '\0']
print(strlen(a))
```

### Python에서의 문자열 처리

- char 타입 없음
- 텍스트 데이터의 취급 방법이 통일되어 있음
- 문자열 기호
    - `'`, `"`, `'''`, `"""`
    - `+` 연결(Concatenation)
        - 문자열 + 문자열 : 이어 붙여주는 역할
    - `*` 반복
        - 문자열 * 수 : 수만큼 문자열이 반복
- 문자열은 시퀀스 자료형으로 분류되고, 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있음
- 문자열 클래스에서 제공되는 메소드
- `replace()`, `split()`, `isalpha()`, `find()`
- **문자열은 튜플과 같이 요소 값을 변경할 수 없음(immutable)**

### C와 Java String 처리의 기본적인 차이점

- C는 아스키 코드로 저장한다.
- Java는 유니코드(UTF16, 2byte)로 저장한다.
- Python은 유니코드(UTF8)로 저장한다.

### Python에서 문자열 뒤집기

```python
# ex) s = 'Reverse this strings' -> 'sgnirts siht esreveR'

# Sol1
s = s[::-1]

# Sol2
s = list(s)
s.reverse()
s = ''.join(s)
```

- C : `strcmp()` 함수
- Java : `equals()` 메소드
- Python : `==`, `is` 연산자

### Python에서 문자열 숫자를 정수로 변환하기

- C : `atoi()`, `itoa()`
- Java : `parse()`, `toString()`
- Python : `int()`, `float()`, `str()`, `repr()`

```python
## int() 만들기
def atoi(s):
    i = 0:
    for x in s:
        i = i*10 + ord(x) - ord('0')
    return i
```

## 패턴 매칭

### 고지식한 패턴 검색 알고리즘

- 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 된다.
- 길이가 10000인 문자열에서 길이 80인 패턴을 찾는다고 할 때, 최악의 경우 약 10,000*80 = 800,000번의 비교가 일어난다.
- 비교 횟수를 줄일 수 있는 방법은 없는가?

### KMP 알고리즘

- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행한다.
- 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화한다.
- `next[M]` : 불일치가 발생했을 경우 이동할 다음 위치
- 시간 복잡도 : O(M+N)
- 아이디어 설명
    - 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용할 수 있다.
    - 실패한 텍스트 문자와 P[4]를 비교한다.
    - 즉, 매칭이 실패했을 때 돌아갈 곳을 계산한다.

```python
# T : Target, P : Pattern
# lps : 패턴의 0부터 i까지 문자열에서 suffix와 동일한 가장 긴 prefix

def pre_process(p):
    lps = [0] * len(p)

    # lps를 만들기 위해 패턴 인덱스
    j = 0

    # 처음부터 끝까지 순회
    for i in range(1, len(p)):
       # 패턴 발견, 해당 인덱스에 있는 char가 동일하면
       if p[i] == p[j]:
            lps[i] = j+1
            j += 1

       # 다르다면, j 인덱스를 초기화 => 패턴의 가장 처음부터 다시 인식하도록
       else:
           j = 0
           if p[i] == p[j]:
               lps[i] = j + 1
               j += 1

    return lps

p = 'abcdabcef'
rlt = pre_process(p)
print(rlt) # [0, 0, 0, 0, 1, 2, 3, 0, 0]
```

### 보이어-무어 알고리즘

- 오른쪽에서 왼쪽으로 비교
- 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
- 보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼이 된다.
- 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재할 경우에는 패턴에서 일치하는 문자를 찾아서 점프한 후 이동한다.

### 카프-라빈 알고리즘

- 앞의 두 매칭 알고리즘들의 공통점 텍스트 문자열의 문자를 적어도 한번씩 훑는다는 것이다. 따라서 최선의 경우에도 Ω(n)이다.
- 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다.
- 발상의 전환 : 패턴의 오른쪽부터 비교한다.
- 최악의 경우 수행시간 : Θ(mn)
- 입력에 따라 다르지만 일반적으로 Θ(n)보다 시간이 덜 든다.