## 비트 연산 예제2
def Bbit_print(i):
    output = ''
    for j in range(7, -1, -1):
        output += '1' if i & (1 << j) else '0'
    print(output, end = ' ')
a = 0x10 # 0x : 16진수
x = 0x01020304
print('%d = ' % a, end = ' ')
Bbit_print(a)
print()
print('0%x = ' % x, end = '')
for i in range(0, 4):
    Bbit_print((x >> i*8) & 0xff)

'''
16 =  00010000 
01020304 = 00000100 00000011 00000010 00000001 # 04 03 02 01
'''
```

- 엔디안(Endianness)
    - 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 **HW 아키텍처마다 다르다**.
    - 주의 : 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바르게 이해하지 않으면 오류를 발생시킬 수 있다.
    - 빅 엔디안(Big-endian) : 보통 큰 단위가 앞에 나옴. 네트워크
    - 리틀 엔디안(Little-endian) : 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터.

| 종류 | 0x1234의 표현 | 0x1234567의 표현 |
| --- | --- | --- |
| 빅 엔디안 | 12 34 | 12 34 56 78 |
| 리틀 엔디안 | 34 12 | 78 56 34 12 |

```python
import sys
print(sys.byteorder) # little (or big)
```

```python
## 비트 연산 예제3
def ce(n): # change endian
    p = []
    for i in range(0, 4):
        p.append((n >> (24-i*8)) & 0xff)
    return p

x = 0x01020304
p = []
for i in range(0, 4):
    p.append((x >> (i*8)) & 0xff)

print('x = %d%d%d%d' % (p[0], p[1], p[2], p[3]))
p = ce(x)
print('x = %d%d%d%d' % (p[0], p[1], p[2], p[3]))

'''
x = 4321
x = 1234
'''

## 비트 연산 예제4
def ce1(n):
    return (n << 24 & 0xff000000) | (n << 8 & 0xff0000)
        | (n >> 8 & 0xff00) | (n >> 24 & 0xff)

## 비트 연산 예제5
def Bbit_print(i):
    output = ''
    for j in range(7, -1, -1):
        output += '1' if i & (1 << j) else '0'
    print(output)
a = 0x86
key = 0xAA

print('a --> ', end = '')
Bbit_print(a)

print('a^=key --> ', end = '')
a ^= key;
Bbit_print(a)

print('a^=key --> ', end = '')
a ^= key;
Bbit_print(a)

'''
a --> 10000110
a^=key --> 00101100
a^=key --> 10000110
'''
```

## 진수 (2, 8, 10, 16진수)

- 2진법 -3자리씩 묶음→ 8진법
- 8진법 -3자리씩 나열→ 2진법
- 8진법 -2자리씩 묶음→ 16진법
- 16진법 -2자리씩 나열→ 8진법
- 2진법 -4자리씩 묶음→ 16진법
- 16진법 -4자리씩 나열→ 2진법

### 컴퓨터에서의 음의 정수 표현 방법

- 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환한다.
    - -6 : 1000000000000110 = 부호와 절댓값 표현
    - -6 : 1111111111111001 = 1의 보수 표현

- 2의 보수 : 1의 보수 방법으로 표현된 값의 최하위 비트에 1을 더한다.
    - +6 : 1111111111111010 = 2의 보수 표현
    - 1의 보수 표현 값이 `num`이면
    - `~num + 1`

## 실수

| 2진수 | 10진수 값 | 2진수 | 10진수 값 |
| --- | --- | --- | --- |
| 0.0000 | 0 | 0.1000 | 0.5 |
| 0.0001 | 0.0625 | 0.1001 | 0.5625 |
| 0.0010 | 0.125 | 0.1010 | 0.625 |
| 0.0011 | 0.1875 | 0.1011 | 0.6875 |
| 0.0100 | 0.25 | 0.1100 | 0.75 |
| 0.0101 | 0.3125 | 0.1101 | 0.8125 |
| 0.0110 | 0.375 | 0.1110 | 0.875 |
| 0.0111 | 0.4375 | 0.1111 | 0.9375 |

- 실수의 표현
    - 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다.
    - 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.
        - 소수점의 위치를 왼쪽의 가장 유요한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현

- 실수를 저장하기 위한 형식
    - 단정도 실수 : 부호 1비트 + 지수 8비트 + 가수 23비트
    - 배정도 실수 : 부호 1비트 + 지수 1비트 + 가수 52비트
    - 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
    - 지수부(exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것