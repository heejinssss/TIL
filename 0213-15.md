# 0213~0215 : Stack

- Function call
    - 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
        - **가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출** 구조이므로, 후입선출 구조의 스택을 이용하여 수행순서 관리
        - 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임(stack frame)에 저장하여 시스템 스택에 삽입
        - 함수의 실행이 끝나면 시스템 스택의 top 원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하

재귀호출 → 반복문처럼 분석 X

Memoization

```python
# memo를 위한 배열을 할당하고, 모두 0으로 초기화
# memo[0]을 0으로 memo[1]을 1로 초기화

def fibo1(n):
    global memo
    if n >= 2 and memo[n] == 0:
        memo[n] = (fibo1(n-1) + fibo1(n-2))
    return memo[n]

memo = [0] * (n+1)
memo[0] = 0
memo[1] = 1
```

Dynamic Programming

```python
def fibo2(n):
    f = [0]*(n+1)
    f[0] = 0
    f[1] = 1
    for i in range(2, n+1):
        f[i] = f[i-1] + f[i-2]

    return f[n]
```

비선형구조인 그래프 구조는, 표현된 모든 자료를 빠짐없이 탐색하는 것이 중요하다. 그래서 아래와 같은 탐색 기법이 존재

## DFS(깊이우선탐색)

시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법

가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용

1) 시작 정점  v를 결정하여 방문한다.

2) 정점 v에 인접한 정점 중에서

(1) 방문하지 않은 정점 w가 있으면, **정점 v를 스택에 push**하고 정점 w를 방문한다.

그리고 w를 v로 하여 다시 2)를 반복한다.

(2) 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2)를 반복한다.

3) 스택이 공백이 될 때까지 2)를 반복한다.

가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 계속 반복 탐색하여 모든 정점을 탐색한다.

스택의 후입선출 구조 또는 재귀호출을 통해서 구현하게 된다.

```python
visited = [], stack = []
DFS(v)
    시작점 v 방문:
```

그래프를 표현하는 방법(인접행렬)

1. 딕셔너리 활용

```python
graph = {}

graph['A'] = ['B','C']
graph['B'] = ['D','F']
```

1. 2차원 배열의 활용

```python
'''
  A B C D E F
A 0 1 1 0 0 0
B 0 0 0 1 0 1
C
D
E
F
'''
```

- 코드로 구현하기

```python
'''
7 8 V, E
1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
'''

# V(정점), E(간선)
V, E = map(int, input().split())

arr = [[0] * (V+1) for _ in range(V+1)] # 정점의 길이보다 +1

visited = [0] * (V+1)

for i in range(E):
    n1, n2 = arr[i*2], arr[i*2+1] # 1 2 / 1 3 / 2 4 / 2 5 / 4 6 / 5 6 / 6 7 / 3 7
    arr[n1][n2] = 1 # n1과 n2는 인접했다는 뜻
```

- 탐색하기

```python
def dfs(v):
    visited[v] = 1

    # 현재 v는 시작 정점!
    # 인접한 정점 중 방문하지 않은 곳
    for w in range(1, V+1):
        if arr[v][w] == 1 and visited[w] == 0:
            dfs(w)

dfs(1)
```

```python
icp : in - coming priority
isp : in - staack priority

if (icp > isp):
    push()
else:
    pop()
```

후위 표기법으로 표현된 수식

| 6 | 5 | 2 | 8 | - | * | 2 | / | + |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |

## 백트랙킹

- 해를 찾는 도중 막히면, 즉 해가 아니면, 되돌아가서 다시 해를 찾아가는 기법
- 최적화(optimization) 문제와 결정(decision) 문제를 해결할 수 있다.
- 결정 문제 : 문제의 조건을 만족하는 해가 존재하는지의 여부를 ‘yes’ 또는 ‘no’가 답하는 문제
    - 미로 찾기
    - n-Queen 문제
    - Map coloring
    - 부분 집합의 합(Subset Sum) 문제 등

## 백트랙킹 vs 깊이우선탐색

- 어떤 노드에서 출하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도 횟수를 줄임
- 깊이우선탐색이 모든 경로를 추적하는데 비해 백트랙킹은 불필요한 경로를 조기에 차단
- 깊이우선탐색을 가하기에는 경우의 수가 N!으로 많기 때문에 처리 불가능한 경우 존재
- 백트랙킹 역시 최악의 경우 지수함수 시간(Exponential Time)을 요하기 때문에 처리 불가능한 경우 존재

## 백트랙킹

- 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 감
- 어떤 노드를 방문하였을 때, 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 하며, 반대로 해답의 가능성이 있으면 유망하다고 한다.
- 가지치기(Pruning) : 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않는다.

## 백트랙킹 절차

1. 상태 공간 트리의 깊이 우선 검색을 실시
2. 각 노드가 유망한지 점검
3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색 반복

```python
def checknode(V):
    if promising(v):                        # 유망한 해이면
        if there is a solution at v:        # 최종 해이면
            write the solution              # 해 출력
        else:                               # 최종 해가 아니라면
            for u in each child of v:       # v의 가지를 탐색
                checknode(u)
```

```python
def backtrack(a, k, input):
    global MAXCANDIDATES
    c = [0]*MAXCANDIDATES

    if k == input:
        for i in range(1, k+1):
            print(a[i], end=' ')
        print()
    else:
        k += 1
        ncandidates = construct_candidates(a, k, input, c)
        for i in range(ncandidates):
            a[k] = c[i]
            backtrack(a, k, input)

def construct_candidates(a, k, input, c):
    in_perm = [False] * NMAX

    for i in range(1, k):
        in_perm[a[i]] = True
    
    ncandidates = 0
    for i in range(1, input+1):
        if in_perm[i] == False:
            c[ncandidates] = i
            ncandidates += 1
    return ncandidates

NMAX = 11
MAXCANDIDATES = 10
a = [0]*NMAX
backtrack(a, 0, 3)
```

## 후위 표기법

- 중위 표기법 : 일반적인 산술 방식
- 후위 표기법 : 컴퓨터가 이해하는 산술 방식